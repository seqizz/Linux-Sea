<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>Linux'u Çalıştırmak</title>

  <section>
    <title>Giriş</title>

    <para>Linux ile çalışmak için bir Linux ortamına ihtiyacınız var. Bunun 
    için en iyi ortam sisteminizde kurulu bir Linux dağıtımı, ancak çalışan 
    CD'ler (başlattığınızda kullanıma hazır işletim sistemi ortamı sunan 
    CD'ler) gibi değişik ortamları da kullanabilirsiniz. Linux'u sisteminize kurma işlemi dağıtıma özgüdür ve Gentoo'nun kurulum prosedürü <ulink
    url="http://www.gentoo.org/doc/en/handbook">Gentoo web sitesinde</ulink> 
    gayet iyi biçimde anlatılmıştır. Şimdilik kurulum işleminden 
    bahsetmeyeceğim. Kitabın ilerleyen kısımlarında komut satırından Gentoo 
    kurulumuna yoğunlaşacağım. Çünkü o zaman bazı kurulum adımları sizin için 
    çok daha anlaşılır olacak. Şimdi Linux'a özel bazı önemli başlıklar 
    hakkında konuşacağım, ama fazla derine inmeyeceğim. İlerde her başlık 
    gayet uzun bir şekilde ele alınacak.</para>

    <para>Unix veya Linux kullanım deneyimine sahip olmayan kullanıcılar bu 
    ortamı diğer işletim sistemlerinden oldukça farklı bulacaklardır 
    (özellikle Microsoft Windows'dan). <link linkend="runninglinux_systemarchitecture">Sistem yapısı</link> hakkında ana 
    farklardan bahsederek hızlı bir değerlendirme yapacağım. Aşağı kısımlarda 
    (Gentoo Linux kullanmak için olmazsa olmaz bir özellik olan) Linux komut 
    satırında çalışma ile ilgili detaylara gireceğim. Kapanışı da komutlar ile 
    ilgili yardım bulabileceğiniz ortamları söyleyerek yapacağım.</para>
  </section>

  <section>
    <title id="runninglinux_systemarchitecture">Sistem Yapısı</title>

    <para>Linux çok kullanıcılı bir yapıdadır.
    <emphasis>root</emphasis><indexterm>
        <primary>root</primary>

        <secondary>kullanıcı</secondary>
      </indexterm> olarak bilinen yönetici sistemde istediği herşeyi 
      yapabilir. Bu yönetici hesabı ile çalışmanız gayet mümkün olmakla 
    birlikte, sisteme erişmesi gereken herkes için ayrı bir kullanıcı açıp 
    sadece gerekli olanlara önemli kaynaklara ve yönetim komutlarına ulaşma 
    hakkı tanımanız tavsiye edilmektedir (bir kullanıcıdan diğerine geçmek 
    veya tek bir komutu başka bir kullanıcının adına çalıştırmak için 
    gerekli araçlar bulunmakta).</para>

    <para>Kişisel bilgisayarınız için bu muhtemelen kendiniz için tek bir 
    kullanıcı açmanız gerektiği anlamına gelir. Eğer paylaşılan bir bilgisayar 
    ise (örneğin ev halkına ait bilgisayar veya işyerindeki  bilgisayar) büyük 
    olasılıkla herkes için ayrı bir kullanıcı açmak isteyeceksiniz. Bir hesabı 
    paylaşmak iyi bir durum değildir. Eğer dosya ve dizinleri diğer insanlarla 
    paylaşmak istiyorsanız, aynı hesabı kullanmaktan daha iyi seçenekleriniz 
    bulunmakta.</para>

    <para>Kullandığınız kişisel hesap sınırlı hesaptır ancak kullanışsız 
    değildir. Yetkilendirilmemiş bir kullanıcı hesabı ile root hesabının 
    arasındaki bazı farklar şöyle sıralanabilir:</para>

    <itemizedlist>
      <listitem>
        <para>kişisel hesap sadece kendi oluşturduğu dosyaları düzenleyebilir. 
        İşletim sistemi dosyaları kullanıcılar tarafından değiştirilemediği 
        için bir kullanıcının sistemi bozma ihtimali ortadan kalkar. Bu ayrıca 
        kişisel bir hesabın sisteme ek bir uygulama kuramaması anlamına da 
        gelmektedir (ancak bu sorun değil - ilerde sisteminizi dönetmeye 
        ihtiyaç duyduğunuzda gerekli hakları nasıl alacağınızı anlatacağım).
        </para>
      </listitem>

      <listitem>
        <para>kişisel hesap bir disk bölümünü sistemi tehlikeye sokacak kadar 
        dolduramaz: Öntanımlı olarak her bölümün %5lik bir kısmı sadece 
        yetkili kullanıcılara ayrılmıştır</para>
      </listitem>

      <listitem>
        <para>eğer kullanıcı hesabında şüpheli hareketler olursa, bunun izleri 
        o kullanıcının ulaşamadığı kayıt dosyalarında görülebilir</para>
      </listitem>

      <listitem>
        <para>...</para>
      </listitem>
    </itemizedlist>

    <para>Kullanıcının başlattığı her görev sistemde bir işlem olarak belirir. 
    Örneğin, tarayıcıyı çalıştıran bir kullanıcı tarayıcı programı temsil eden 
    en az bir işlemin çalışmasından sorumludur. Öntanımlı olarak bu işlem 
    çalıştıran kullanıcının yetkilerine sahip olur, bu yüzden sadece bu 
    kullanıcının ulaşabildiği dosya ve kaynaklara ulaşabilir. root hesabını 
    kullanmamak için bir başka neden ise web tarayıcınızda çalışan bir 
    betiğin, bir güvenlik açığından faydalanarak (ki bu fantezi değildir, böyle 
    şeyler yaşanabilir) sisteminizdeki önemli dosyaları silebilmesidir...</para>

    <para>Dosya ve dizinler ise izin açısından üç farklı izin dalı ile temsil 
    edilir: birincisi sahibi, diğeri grubu ve son olarak da herkes için. Daha 
    sonra dosya izinlerini detaylı olarak ele alacağız.</para>

    <section>
      <title>Kullanıcı Hesapları</title>

      <para>root kullanıcısının yönetici olarak herhangi bir kısıtlamaya tabi 
      olmaması sebebiyle, root tarafından yapılan her hareket potansiyel 
      olarak sisteminize zarar verebilir:</para>

      <itemizedlist>
        <listitem>
          <para>yanlış dosya veya dizinleri silmek (geri getir seçeneği 
          bulunmamakta)</para>
        </listitem>

        <listitem>
          <para>sistem dosyalarını silmek veya düzenlemek (muhtemelen hatalı 
          çalışan bir sisteme sebep olacaktır - ve yeniden başlatmak bu sorunu 
          çözmeyecektir)</para>
        </listitem>

        <listitem>
          <para>ağı devre dışı bırakmak veya ağ politikasını değiştirmek</para>
        </listitem>

        <listitem>
          <para>dosyaları yanlış yere yerleştirmek (muhtemelen dosya kaybı ve 
          sistem işlemlerinde aksamaya sebep olur)</para>
        </listitem>

        <listitem>
          <para>yanlış işlem(ler)i sonlandırmak veya değiştirmek (muhtemelen 
          servis hatası, kapanma veya mantıksız davranışlara sebep olur)</para>
        </listitem>

        <listitem>
          <para>...</para>
        </listitem>
      </itemizedlist>

      <para>Bu sebepten, kullanıcı hesapları oluşturulmalıdır. Öntanımlı bir 
      kullanıcı hesabı:</para>

      <itemizedlist>
        <listitem>
          <para>sadece kendine ait dosyaları düzenleyebilir veya silebilir</para>
        </listitem>

        <listitem>
          <para>sistemin tümünü ilgilendiren bir ayarı değiştiremez (ağ veya 
          aygıt erişimi gibi)</para>
        </listitem>

        <listitem>
          <para>dosyaları sadece kendisine atanmış ev dizinine yerleştirebilir
          </para>
        </listitem>

        <listitem>
          <para>sadece kendi çalıştırdığı işlemleri sonlandırabilir / 
          yönetebilir</para>
        </listitem>
      </itemizedlist>

      <important>
        <para>root olmayan bir kullanıcının da sisteme zarar vermesi mümkündür. Örneğin çalıştırılan zararlı bir program sistemdeki tüm kullanıcı dosyalarını silebilir. Bu, işletim sistemini etkileyen dosyalara dokunulmadığı için sistemin çalışmasını etkileyememekle beraber, kullanıcılar için bir felaket anlamına gelir (bu yüzden lütfen düzenli olarak yedek almayı unutmayın).</para>
      </important>

      <para>Kullanıcı hesaplarının yanı sıra her Linux yüklü sistemde <emphasis>sisteme ait hesaplar</emphasis><indexterm>
          <primary>sistem hesapları</primary>
        </indexterm> da bulunur. Bu hesaplar kullanıcı hesapları gibi, 
      sınırlamaları bulunan hesaplardır. Ancak sisteme giriş yapmak için 
      kullanılamazlar (geçerli bir şifreleri yoktur), genellikle ayrı bir ev 
      dizinleri bulunmaz, sadece işletim sisteminin belirlediği işleri 
      kendilerine (güvenlik sebebiyle) verilen sınırlı haklar ile yapmakta 
      kullanılırlar.</para>

      <para>Kullanıcı hesaplarının yönetimini (yetkilerini ve kaynaklara 
      erişimlerinin denetimini) kolaylaştırmak için kullanıcılar gruplara 
      dahil edilirler. Dosyalara erişim grup izinleri ile yönetilebilir ve bu 
      sayede belirlenen gruba üye olan herkes dosyaya erişebilir (hatta 
      dosyayı düzenleyebilir). Bir kullanıcı birden çok gruba dahil olabilir.
      </para>
    </section>

    <section>
      <title>İşlemler</title>

      <para>Bir <emphasis>işlem</emphasis><indexterm>
          <primary>işlem</primary>
        </indexterm> sistemde yürütülen bir görevi simgeler. Her işlem bir 
      kullanıcı tarafından başlatılır, ancak bu o işlemin sadece o 
      kullanıcının yetkisi dahilindeki kaynaklara ulaşabileceği değil, aynı 
      zamanda sadece o kullanıcı (ve root kullanıcısı) tarafından 
      yönetilebileceği (örn. sonlandırılabileceği) anlamına gelir.</para>

      <para>Her işlemin bir üst işlemi (ebeveyni) vardır (en üst işlem olan <command>init</command><indexterm>
          <primary>init</primary>
        </indexterm> işlemi hariç) ve her işlem bir veya birden fazla işleme 
      ebeveynlik yapabilir. Eğer işlem sonlandırılırsa, ebeveyni olduğu 
      işlemler de sonlanacaktır (yani asla 'init' işlemini sonlandırmayın, 
      sistemde çalışan bütün işlemleri sonlandırmaya çalışmış olursunuz).</para>

      <para>İşlem çalıştırmak bilgisayarın işlemcisini yoracak diye bir kural 
      yoktur. Boşta duran bir sistem yüzlerce (hatta binlerce) işlemi 
      arkaplanda çalıştırıyor olabilir. Bunun sebebi işlemlerin belirli 
      durumlara sahip olmasıdır: çalışıyor, uyuyor, beklemede, durdu... Linux 
      işletim sistemi uygulamaların ihtiyaç duyduğu kaynakları eldekiler ile 
      karşılamakta oldukça kabiliyetli olduğu için, son kullanıcı olarak, o 
      kadar fazla işlemin çalıştığını fark etmezsiniz.</para>

      <note>
        <para>Bir işlem birden fazla iş parçacığına sahip olabilir. İş 
        parçacıkları (thread) uygulamanın birer parçasıdır (ama işletim 
        sistemi tarafından yönetilirler) ve uygulama içinde paralel olarak kod 
        çalıştırabilirler. Yüzlerce iş parçacığına sahip bir uygulama dahi tek 
        işlemden oluşur.</para>
      </note>
    </section>

    <section>
      <title>Dosya ve Dizin Yapısı</title>

      <para>Linux'da (ve tüm Unix tabanlı işletim sistemlerinde) dizin sistemi 
      hiyerarşik yapıdadır. En üstte 
      <emphasis>kök dizin</emphasis>
      <indexterm>
          <primary>kök</primary>
          <secondary>dosya sistemi</secondary>
       </indexterm>, diğer bir isim ile "<filename>/</filename>"<indexterm>
          <primary>/</primary>
        </indexterm> bulunmaktadır. Altında önceki bölümde anlattığımız "Dosya 
      Sistemi Hiyerarşisi" standarında uygun olarak dosya ve dizinler bulunur 
      <xref linkend="fhs" />.  Yapıdaki her pozisyonun kendine göre bir anlamı 
      vardır. Örneğin 
      <filename>/home/swift</filename>, "swift" kullanıcısının ev dizini 
      anlamına gelir. Bir diğer örneğimiz 
      <filename>/usr/share/doc/googleearth-4.2.198.2451/</filename>, Google 
      Earth programının o sürümüne ait olan paketin dökümanlarını içermektedir.
      </para>

      <para>Normal dosyaların (örn. yazı dosyaları ve uygulama belgeleri) yanı sıra, Linux'da ayrıca şu dosyalar bulunur:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>bağlantılar</emphasis><indexterm>
              <primary>bağlantı</primary>
            </indexterm>, aynı dosyaya farklı isim ile ulaşmayı sağlayan 
            bağlantı dosyaları (bir dosyaya birden fazla bağlantı atanabilir),
            </para>
        </listitem>

        <listitem>
          <para><emphasis>sembolik bağlar</emphasis><indexterm>
              <primary>bağlantı</primary>

              <secondary>sembolik</secondary>
            </indexterm> diğer dosyaları işaret eden dosyalar. Bağlantılardan 
            ayrıdırlar, çünkü kısayollar olmayan bir dosyayı da işaret 
            edebilirler ve (tamamen olmasa da) Microsoft Windows'daki 
            kısayollara benzerler.</para>
        </listitem>

        <listitem>
          <para><emphasis>borular</emphasis><indexterm>
              <primary>boru</primary>
            </indexterm> veya <emphasis>FIFOlar</emphasis><indexterm>
              <primary>FIFO</primary>
            </indexterm>, bir uygulamanın çıktısını diğer uygulamaların 
            okuması için geçici olarak depolayan dosyalar</para>
        </listitem>

        <listitem>
          <para><emphasis>unix soketleri</emphasis><indexterm>
              <primary>unix soketi</primary>
            </indexterm>, yani bir işlem tarafından oluşturulan ve diğer 
          birçok işlemin bilgi alabileceği veya yazabileceği akışı sağlayan
          dosyalar</para>
        </listitem>

        <listitem>
          <para><emphasis>karakter</emphasis><indexterm>
              <primary>aygıt dosyası</primary>

              <secondary>karakter</secondary>
            </indexterm> ve <emphasis>blok aygıtı dosyaları</emphasis><indexterm>
              <primary>aygıt dosyası</primary>

              <secondary>blok</secondary>
            </indexterm>, normal dosya işlemleri ile bir aygıt (donanım) 
          arasındaki iletişimi sağlayan dosyalar</para>
        </listitem>
      </itemizedlist>

      <para>Tüm bu özel dosyalar Linux dosya sisteminde birer dosya olarak 
      temsil edilir. Örnek olarak <filename>/dev/sda1</filename>'i ele alalım. 
      Sistem tarafından bilinen ilk (<filename>a</filename>) SCSI aygıtının (
      <filename>sd</filename>) birinci bölümünü (<filename>1</filename>) 
      temsil eder. <filename>/dev/sda1</filename> bir blok aygıtı dosyasıdır 
      çünkü okuma yazma işlemleri blok (belirli gruplar) halinde uygulanır. 
      Karakter aygıtlarında bu işlem karakter başına yapılmaktadır.</para>

      <para>İlerdeki bir bölümde aygıt dosyaları ve Linux'un onları yönetim 
      şeklinden bahsedeceğim.</para>
    </section>

    <section>
      <title>İzinler</title>

      <para>Dosyalar (dizinler ve bahsettiğimiz özel dosyalar dahil, bu noktadan sonra hepsine genel olarak dosyalar olarak hitap edeceğim) üç grup izinle<indexterm>
          <primary>izinler</primary>
        </indexterm> ilişkilidir. Birisi sahibi için, diğeri grubu için, son 
      olarak da geri kalan herkes için. Bunların her biri birçok bayrak içerir:
      </para>

      <itemizedlist>
        <listitem>
          <para>dosya veya dizini okuma izni</para>
        </listitem>

        <listitem>
          <para>dosya veya dizine yazma izni</para>
        </listitem>

        <listitem>
          <para>dosyayı çalıştırma izni (muhtemelen bir betik veya uygulama 
          dosyası olmasından dolayı) veya dizine girme izni (dizinin içine 
          dalma anlamında)</para>
        </listitem>
      </itemizedlist>

      <para>Bu üç grubun yanı sıra çalıştırılabilir dosyalar ve dizinler için 
      ek izinler ayarlanabilir, ancak daha az öneme sahip olduklarını 
      söyleyebiliriz:</para>

      <itemizedlist>
        <listitem>
          <para>bir dosyaya <emphasis>kullanıcı/grup kimliği ayarlama</emphasis><indexterm>
              <primary>kullanıcı kimliği ayarlama</primary>
            </indexterm><indexterm>
              <primary>grup kimliği ayarlama</primary>
            </indexterm>, yani dosya çalıştırıldığında işlemin onu çalıştıran 
          kullanıcı tarafından değil, sahibi tarafından çalıştırılmış 
          görünmesini sağlama veya (dizinlere uygulandığında) dizinin içinde 
          oluşturulan dosyaları otomatik olarak bir grubun sahipliğine vermeye 
          yarar.</para>
        </listitem>

        <listitem>
          <para><emphasis>silme kısıtlaması</emphasis><indexterm>
              <primary>silme kısıtlaması bayrağı</primary>
            </indexterm> bayrağı (etkilenen dizinin içindeki dosyaları dosya 
          veya dizinin sahibi olmayan kullanıcıların silmesini engeller)</para>
        </listitem>
      </itemizedlist>

      <para>Silme kısıtlaması bayrağını biraz açıklayalım. Yazma izni genele 
      açık olan dizinlerde kullanılır (iyi bilinen bir örnek olarak geçici 
      dosyaların tutulduğu <filename>/tmp</filename>` dizinini verebiliriz) ve 
      kullanıcıların kendi oluşturmadıkları dosyaları silmesini engeller. 
      Yazma izni genele açık olan bir dizin normalde diğer kullanıcıların 
      içindeki dosyaları silmesine olanak tanır (çünkü onların da dizine yazma 
      hakları vardır). Silme kısıtlaması bayrağı aynı zamanda 
      <emphasis>yapışkan</emphasis><indexterm>
          <primary>yapışkan bayrak</primary>
        </indexterm> bayrak olarak da bilinir.</para>
    </section>
  </section>

  <section>
    <title>Komut Satırını Kullanmak</title>

    <para>Çoğu Linux dağıtımı başlatıldıktan sonra size grafiksel bir giriş ekranı sunar, hatta bazıları otomatik olarak masaüstüne giriş yapar. Gentoo Linux'da durum böyle değildir. Bunun yerine komut satırı ekranı sizi karşılar ve kendinizi tanımlamanızı ister:</para>

    <programlisting>This is seaheaven.homeworld (Linux i686 2.6.23) 22:30:00

seaheaven login: </programlisting>

    <para>Bu ekranda, (Linux kurulumu sırasında mutlaka oluşturmuş olduğunuz) 
    kullanıcı adınızı girmeniz gerekir. Sonraki adımda hesabınızın şifresini 
    girmenizi ister. Eğer girdiğiniz kullanıcı adı sistemde bulunuyorsa ve 
    şifre de eşleşiyorsa, komut satırına giriş yaparsınız. Örneğin "captain" 
    kullanıcı adı ile giriş yaptığınız "seaheaven" adına sahip bir makinada 
    tipik bir <emphasis>komut istemi satırı</emphasis><indexterm>
        <primary>komut istemi</primary>
      </indexterm> şu şekilde görünür:</para>

    <programlisting>captain@seaheaven ~ $</programlisting>

    <para>Bu komut satırındaki yapı şu şekildedir:</para>

    <orderedlist>
      <listitem>
        <para>sisteme giriş yapmış olan kullanıcı</para>
      </listitem>

      <listitem>
        <para>kullanıcının giriş yaptığı bilgisayarın adı</para>
      </listitem>

      <listitem>
        <para>kullanıcının dosya sistemindeki mevcut yeri (~ işareti 
        kullanıcının ev dizini anlamına gelir)</para>
      </listitem>

      <listitem>
        <para>kullanıcının normal kullanıcı ($) mı yoksa root (#) mu olduğunu 
        belirten bir istemci işareti.</para>
      </listitem>
    </orderedlist>

    <para>Sonraki bölümlerde size Linux komut satırı dünyasını hızlı bir 
    şekilde tanıtacağım.</para>

    <section>
      <title>Dolaşma</title>

      <para>Komut istemcisi aslında kabuk tarafından sunulan bir hizmettir. 
      <emphasis>Kabuk</emphasis><indexterm>
          <primary>kabuk</primary>
        </indexterm>, kullanıcıdan klavye yoluyla aldığı komutları sistemde 
      çalıştıran etkileşimli bir uygulamadır. Komutlara önemli bir örnek 
      olarak dosya sistemi içerisinde gezinmeyi sağlayan komutları verebiliriz:</para>

      <itemizedlist>
        <listitem>
          <para><command>pwd</command><indexterm>
              <primary>pwd</primary>
            </indexterm> komutu kullanıcının içinde bulunduğu dizini gösterir</para>
        </listitem>

        <listitem>
          <para><command>cd</command><indexterm>
              <primary>cd</primary>
            </indexterm> komutu kullanıcının içinde olduğu dizini değiştirmeyi 
          sağlar</para>
        </listitem>

        <listitem>
          <para><command>ls</command><indexterm>
              <primary>ls</primary>
            </indexterm> komutu kullanıcının bulunduğu veya istediği bir 
          dizinin içeriğini görüntüler</para>
        </listitem>
      </itemizedlist>

      <para>Örnek bir oturum aşağıda gösterilmiştir.</para>

      <programlisting>captain@seaheaven ~ $ <command>pwd</command>
/home/captain
captain@seaheaven ~ $ <command>ls</command>
Documents     Movies       Music       Pictures
opentasks.txt
captain@seaheaven ~ $ <command>cd Documents</command>
captain@seaheaven Documents $ <command>pwd</command>
/home/captain/Documents</programlisting>

      <para>Bir dizinden diğerine geçmek için <command>cd</command> komutunu 
      kullanmanın birkaç yolu vardır. <command>pwd</command> komutunun içinde 
      bulunduğunuz dizini görmek için kullandığınızı unutmayın. Dosyalar 
      içinde gezmek için <command>pwd</command> komutu bir işe yaramaz!</para>

      <itemizedlist>
        <listitem>
          <para>Dosya sistemi ağacında derinlere inmek için ilişkili dizin adını kullanabilirsiniz. Örnekte, "<filename>Documents</filename>" ilişkili dizinini kullanarak, "<command>cd Documents</command>" komutu ile <filename>/home/captain</filename> dizininden <filename>/home/captain/Documents</filename> dizinine geçiş yapılmakta. </para>

          <programlisting>$ <command>pwd</command>
/home/captain
$ <command>cd Documents</command>
$ <command>pwd</command>
/home/captain/Documents</programlisting>
        </listitem>

        <listitem>
          <para>Üst dizine çıkmak için özel bir isim olan <filename>..
          </filename> (nokta nokta) kullanabilirsiniz. Yani <command>cd ..
          </command> komutu <filename>/home/captain/Documents</filename> 
          dizininden <filename>/home/captain</filename> dizinine geçiş yapar.
          </para>

          <programlisting>$ <command>pwd</command>
/home/captain/Documents
$ <command>cd ..</command>
$ <command>pwd</command>
/home/captain</programlisting>
        </listitem>

        <listitem>
          <para>Ayrıca tam dizin isimleri de kullanabilirsiniz. Örneğin acilen <filename>/etc/init.d</filename> dizinine (ilerde bahsedeceğimiz önemli bir dizin) gitmek için <command>cd /etc/init.d</command> komutu vermelisiniz.</para>

          <programlisting>$ <command>pwd</command>
/home/captain/Documents
$ <command>cd /etc/init.d</command>
$ <command>pwd</command>
/etc/init.d</programlisting>
        </listitem>

        <listitem>
          <para>Özel bir işaret olan <filename>~</filename><indexterm>
              <primary>~</primary>
            </indexterm> (benzer işareti) ev dizini anlamına gelir, yani
          "<command>cd ~</command>" komutu sizi ev dizinine götürür. Hatta
          sadece "<command>cd</command>" komutu ile de ev dizininize 
          ulaşabilirsiniz. <filename>~</filename> iki şekilde kullanılabilir:
          ev dizininizi yazmak yerine (<command>cd ~/Documents</command> 
          kullanarak <filename>/home/captain/Documents</filename>) dizinine 
          veya başka bir kullanıcının ev dizinine, tam yolu (<filename>
          /home/raghat/public_html</filename>) yazmak yerine <command>~
          </command> ile birlikte kullanıcı adını kullanarak ("<command>cd
          ~raghat/public_html/</command>") ulaşabilirsiniz.</para>

          <programlisting>$ <command>pwd</command>
/etc/init.d
$ <command>cd ~/Documents</command>
$ <command>pwd</command>
/home/captain/Documents</programlisting>
        </listitem>
      </itemizedlist>

      <para>Eğer herhangi bir sebepten dolayı (örn. izninizin olmaması veya 
      belirttiğiniz dizinin bulunamaması) dizine girme işlemi başarısız olursa 
      bununla ilgili hata mesajı alacaksınız.</para>

      <programlisting>$ <command>pwd</command>
/home/captain
$ <command>cd /etc/cron.daily</command>
bash: cd: /etc/cron.daily: Permission denied
$ <command>pwd</command>
/home/captain</programlisting>
    </section>

    <section>
      <title>İçeriği Sıralamak</title>

      <para>Bir dizinin içeriğini sıralamak için <command>ls</command> 
      komutunu kullanırsınız. Öntanımlı olarak bulunduğunuz dizindeki dosya ve 
      dizinleri görüntüleyen komut, oldukça fazla görüntüleme seçeneği 
      sunmakta. Tüm seçenekleri tek tek anlatma niyetinde değilim, ancak şu 
      anda bilmeniz gereken birkaç önemli özellik var.</para>

      <para>İlk olarak "<command>-l</command>" seçeneği sadece bulunduğunuz 
      (ya da ismini verdiğiniz) dizinin içeriğini göstermek ile kalmaz, aynı 
      zamanda her dosya ve dizin hakkında bilgi de verir: </para>

      <programlisting>captain@seaheaven ~ $ <command>ls -l</command>
drwxr-xr-x 2 captain users 4096 2007-10-31 22:24 Documents
drwxr-xr-x 2 captain users 4096 2007-10-31 22:24 Movies
drwxr-xr-x 2 captain users 4096 2007-10-31 22:25 Music
drwxr-xr-x 2 captain users 4096 2007-10-31 22:24 Pictures
-rw-r--r-- 1 captain users   66 2007-10-31 22:30 opentasks.txt</programlisting>

      <para>Verilen bilgiler arasında izin bilgileri (üç kez üç karakter: Okuma, Yazma ve Çalıştırma), sahip olan kullanıcı ve grup, boyut (dizinler 4'ün katlarından oluşmakta) ve oluşturulma zamanları bulunmaktadır.</para>

      <para>Bir diğer ilgi çekici seçenek ise (gizli dosyalar dahil) tüm dosyaları göstermeye yarayan "<command>-a</command>",  seçeneği. Unix / Linux sistemlerde
      <emphasis>gizli dosyalar</emphasis><indexterm>
          <primary>gizli dosya</primary>
        </indexterm> isminin başında nokta bulunduran dosyalardır. Öntanımlı 
      olarak ev dizininizde gizlenmiş bir sürü dosya bulacaksınız, bunlara bir 
      örnek olarak:</para>

      <programlisting>captain@seaheaven ~ $ <command>ls -a</command>
Documents    Movies    Music    Pictures
.history     .maildir  .profile .vimrc</programlisting>

      <para>Bir dosyanın gizli olması onu gerçekten saklamaya değil, normal 
      kullanımda fazla ön plana çıkmamasını sağlamaya yarar. Bu şekilde 
      listeleme esnasında da kirliliğin önüne geçilmiş olur. Gizli dosyaların 
      çoğu ayar dosyalarıdır (vim editörünün kullanıcı ayarlarını saklayan 
      .vimrc dosyası gibi).</para>

      <para>Çoğu komut satırı aracında olduğu gibi parametreleri beraber 
      kullanabilirsiniz, hatta birleştirebilirsiniz. Yani <command>ls -l -a
      </command> ile <command>ls -la</command> aynı komuttur. Ayrıca sıra da 
      önemli olmadığı için <command>ls -al</command> da aynı görevi görür.</para>

      <section>
        <title>ls -l çıktısını inceliyoruz</title>

        <para>"<command>ls -l</command>" komutunu bir dosya veya dizinden 
        bilgi almak için sıkça kullanacaksınız. Bu yüzden <command>ls</command>
        'in çıktısına kısaca göz atacağım:</para>

        <programlisting>$ <command>ls -l 12-servicemanagement.xml</command>
-rw-r--r-- 1 swift users 26976 Apr 22 21:21 12-servicemanagement.xml
|&lt;+&gt;&lt;+&gt;&lt;+&gt; | &lt;-+-&gt; &lt;-+-&gt; &lt;-+-&gt; &lt;-----+----&gt; &lt;---------+-------------&gt;
| |  |  |  |   |     |     |         |                `- dosya veya dizin adı
| |  |  |  |   |     |     |         `- son düzenleme tarihi
| |  |  |  |   |     |     `- boyut (byte olarak)
| |  |  |  |   |     `- dosya veya dizine sahip olan grup
| |  |  |  |   `- dosya veya dizine sahip olan kullanıcı
| |  |  |  `- dosya veya dizine olan bağlantı (hard link) sayısı
| |  |  `- herkes için izinler (bu örnekte "sadece okuma" ayarlanmış)
| |  `- sahibi olan grup ("users") için izinler (bu örnekte "sadece okuma")
| `- sahibi olan kullanıcı ("swift") için izinler (bu örnekte "okuma ve yazma")
`- dosyanın türü (bu örnekte: normal dosya)</programlisting>
      </section>
    </section>

    <section>
      <title>Temel Dosya Yönetimi</title>

      <para>Aşağıda en temel dosya yönetim işlemlerini açıklayacağız; 
      kopyalama, taşıma, yeniden adlandırma ve silme...</para>

      <section>
        <title>Dosya ve Dizinleri Kopyalama</title>

        <para>Bir dosyayı kopyalamak için <command>cp</command><indexterm>
            <primary>cp</primary>
          </indexterm> komutu kullanılır. Temel kullanımı basittir: <emphasis>cp
        kaynak hedef</emphasis>. Hedef bir dizin olabilir, bu durumda dosya o 
        dizinin içine kopyalanacaktır. Eğer hedef bir dosya adı ise dosya o 
        isimle kaydedilecektir.</para>

        <programlisting>captain@seaheaven ~ $ <command>ls Documents</command>
captain@seaheaven ~ $ <command>cp opentasks.txt Documents/tasks.txt</command>
captain@seaheaven ~ $ <command>ls Documents</command>
tasks.txt
captain@seaheaven ~ $ <command>cp opentasks.txt Documents</command>
captain@seaheaven ~ $ <command>ls Documents</command>
opentasks.txt      tasks.txt</programlisting>

        <para>Öntanımlı olarak <command>cp</command> komutu hedef dosyayı 
        komutu çalıştıran kullanıcının hakları ve sahipliği ile oluşturur. 
        Gelecek örnekte <filename>/etc/inittab</filename> dosyasını bulunduğum 
        dizine (.) kopyalayacağım:</para>

        <programlisting>$ <command>ls -l /etc/inittab</command>
-rw-r--r-- 1 root root 1890 Feb 15 20:39 /etc/inittab
$ <command>cp /etc/inittab .</command>
$ <command>ls -l inittab</command>
-rw-r--r-- 1 swift users 1890 Apr 22 22:49 inittab</programlisting>

        <para><command>cp</command> komutundan bütün bilgileri (erişim 
        izinleri, dosya sahipliği ve zamanlar) korumasını isteyebilirsiniz, 
        ancak bunun için bazı durumlarda root olmanız gerekebilir.</para>

        <para>Bir dizini ve içindeki derinlemesine tüm dosyaları kopyalamak için <command>-r</command> seçeneği kullanılır. Sıradaki örnek <filename>workdocuments</filename> dizinini (içindeki tüm dosya ve dizinlerle beraber) bulunduğunuz dizine kopyalar.</para>

        <programlisting>$ <command>cp -r /media/usb/workdocuments .</command></programlisting>
      </section>

      <section>
        <title>Dosyaları Taşıma ve Yeniden Adlandırma</title>

        <para>Bir dosyayı taşımak için <command>mv</command><indexterm>
            <primary>mv</primary>
          </indexterm> komutu kullanılmalıdır. Kullanımı <emphasis>mv
        kaynak hedef</emphasis>. şeklindedir. Eğer hedef dizin değil de bir dosya adı ise <command>mv</command> komutu yeniden adlandırma işlemini de gerçekleştirir. Gelecek örnekte
        <filename>tasks.txt</filename> dosyasını
        <filename>Documents</filename> dizininden
        <filename>/media/usb/workdocuments</filename> dizinine taşıyoruz:</para>

        <programlisting>captain@seaheaven ~ $ <command>mv Documents/tasks.txt /media/usb/workdocuments</command>
captain@seaheaven ~ $ <command>ls</command>
opentasks.txt     tasks.txt
captain@seaheaven ~ $ <command>ls /media/usb/workdocuments</command>
opentasks.txt</programlisting>
      </section>

      <section>
        <title>Dosya ve Dizinleri Silmek</title>

        <para>Son görevimiz dosyaları silmek.
        <command>rm</command><indexterm>
            <primary>rm</primary>
          </indexterm> komutunun kullanım şekli: <emphasis>rm
        dosyaadı</emphasis>şeklindedir. Bir dizini silmek için sadece dizin 
        adını verebilirsiniz, ancak bu yöntemde dizinin silinmesi için boş 
        olması gerekir. Doluysa "-r" seçeneğini eklemelisiniz (içindekileri de 
        sil anlamına gelir).</para>

        <programlisting>captain@seaheaven ~ $ <command>rm Documents/opentasks.txt</command>
captain@seaheaven ~ $ <command>rm tasks.txt</command></programlisting>

        <para><command>rm</command> rm komutuna gelen popüler bir seçenek 
        grubu da "<command>-rf</command>": Verdiğiniz hedefteki tüm dosya ve 
        dizinleri derinlemesine silmeyi ve kullanıcıya onay için sormamayı 
        (zorlamayı) emreder. Bunu kullanırken ne yaptığınızdan emin olun, 
        Linux'da geri alma özelliği bulunmamakta!</para>

        <programlisting>$ <command>rm -rf Documents</command></programlisting>

        <para>Neyse ki, <command>rm</command> komutu sadece onu çalıştıran 
        kullanıcının yetkisinin olduğu dosyaları silebilir. Yani eğer yetkili 
        (root) kullanıcı değilseniz sistem dosyalarını kazara silemezsiniz.
        </para>

        <programlisting>$ <command>rm -f /etc/passwd</command>
rm: cannot remove '/etc/passwd': Permission denied</programlisting>
      </section>
    </section>

    <section>
      <title>Yazı Dosyalarını Düzenlemek</title>

      <para>Her Linux kullanıcısının bildiği önemli bir görev de yazı 
      dosyalarını nasıl düzenleyeceğini bilmektir. Kullanabileceğiniz birçok 
      yazı editörü bulunmakta, örneğim popüler vim veya emacs. Gentoo ilk 
      editör olarak nano'yu tavsiye etmekte, çünkü nano ile çalışmak kolay ve 
      anlaşılabilir. Benim tercihim vim'den yana.</para>

      <section>
        <title>Nano'yu Kullanmak</title>

        <para>Nano'nun kısa bir tanıtımını yapalım. Eğer nano komutu 
        verirseniz sizi ana pencere açılarak boş bir yeni belge ile 
        karşılayacaktır. Eğer parametre olarak bir dosya adı verirseniz, 
        verdiğiniz yazı dosyasını düzenlemeye açık halde açacaktır. Örneğin 
        <filename>opentasks.txt</filename> dosyasını nano ile açalım:</para>

        <programlisting>captain@seaheaven ~ $ <command>nano opentasks.txt</command></programlisting>

        <figure float="">
          <title>nano editöründe opentasks.txt dosyası</title>

          <mediaobject>
            <imageobject>
              <imagedata align="left" fileref="images/nano.png" width="10cm" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>İlk satır dosya adını ve son iki satır da gerekli kısayol 
        tuşlarını göstermekte. ^ karakteri Ctrl tuşuna basmanız gerektiği 
        anlamına geliyor. yani dosyayı kaydetmek için Ctrl+O, editörden çıkmak 
        için Ctrl+X kombinasyonlarını kullanmalısınız.</para>

        <para>Bazı yazı dosyaları (ayar dosyaları gibi) yeni satırlara karşı 
        çok duyarlıdır. Öntanımlı olarak nano, yazı satırı doldurduğunda alt 
        satıra geçebilir. Bunu engellemek ve satırları olduğu uzunluklarında 
        bırakmak için <command>-w</command> parametresini kullanabiliriz: "
        <command>nano -w opentasks.txt</command>". Ayar dosyalarını 
        düzenlerken bu kullanım şekli önerilmektedir.</para>
      </section>

      <section>
        <title>Yazı Dosyalarına Bakmak</title>

        <para>Eğer yazı dosyalarının içeriğine bakmak, ancak bir metin editörü 
        kullanmak istemiyorsanız, <command>cat</command> veya
        <command>less</command>araçlarını kullanabilirsiniz. Bu sayede 
        yanlışlıkla düzenleme riskinden de kurtulmuş olursunuz.</para>

        <itemizedlist>
          <listitem>
            <para><command>cat</command><indexterm>
                <primary>cat</primary>
              </indexterm> ile bir dosyanın içeriğini terminale "basarsınız". 
            Eğer dosya büyükse, tüm içerik aynı anda ekrandan akıp gidecektir. 
            Shift+PgUp tuşları ile yukarı doğru bakabilirsiniz ancak terminal 
            önbelleğinin de bir sınırı vardır.</para>
          </listitem>

          <listitem>
            <para><command>less</command><indexterm>
                <primary>less</primary>
              </indexterm> ile bir dosyanın içeriğine sayfa sayfa 
            bakabilirsiniz. Yön tuşları veya PgUp-PgDn tuşları ile yukarı 
            aşağı kaydırma, belirttiğiniz metni arama gibi özelliklere 
            sahiptir.</para>
          </listitem>
        </itemizedlist>

        <para><command>less</command> uygulaması sadece yazı dosyalarını 
        değil, aynı zamanda uygulama yardımı (man) dosyalarını da görüntülemek 
        için kullanılır (bu bölümde ilerde bahsedeceğiz).</para>

        <table>
          <title>less'de sık kullanılan kısayolların bir listesi</title>

          <tgroup cols="2">
            <tbody>
              <row>
                <entry>bir satır aşağı in</entry>

                <entry>e, j, &lt;enter&gt; veya aşağı ok tuşu</entry>
              </row>

              <row>
                <entry>bir satır yukarı çık</entry>

                <entry>y, k veya yukarı ok tuşu</entry>
              </row>

              <row>
                <entry>bir sayfa aşağı in</entry>

                <entry>f, &lt;boşluk&gt; veya PgDown</entry>
              </row>

              <row>
                <entry>bir sayfa yukarı çık</entry>

                <entry>b veya PgUp</entry>
              </row>

              <row>
                <entry>/&lt;aranacakyazı&gt;</entry>

                <entry>ileriye doğru &lt;aranacakyazı&gt;yı ara, sonraki için 
                "<command>n</command>" kullanın</entry>
              </row>

              <row>
                <entry>?&lt;aranacakyazı&gt;</entry>

                <entry>geri doğru &lt;aranacakyazı&gt;yı ara, önceki için 
                "<command>?</command>" kullanın</entry>
              </row>

              <row>
                <entry>h</entry>

                <entry>yardım ekranını göster</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Merak edersiniz diye söyleyelim, <command>less</command> (ing: 
        daha az) ismi daha önceden kullanılan, halen de desteklenmekte olan
        <command>more</command><indexterm>
            <primary>more</primary>
          </indexterm>. (ing: daha fazla) isimli bir sayfalayıcıya ithafen 
        seçilmiştir. <command>more</command> da dosyaları sayfa sayfa 
        göstermesine rağmen, sadece aşağı doğru kaydırmayı desteklemekte. Yani 
        <command>less</command> (az), <command>more</command>(çok)'dan daha 
        fazlası.</para>
      </section>
    </section>

    <section>
      <title>Dosya ve Dizinleri Bağlantılama</title>

      <para>Linux iki çeşit bağlantı (link) türünü destekler: sembolik bağlar ve sert bağlar. Muhtemelen neden tanıtım bölümünde bundan bahsettiğimi merak edeceksiniz. Linux'da sembolik bağlar oldukça sık kullanılır, ayrıca sert bağlar ile ilgili çıktıları da birçok yerde göreceksiniz. Aslında daha önce bu yazıda sert bağlar ile ilgili bir çıktıdan bahsettik, <command>ls -l</command> komutu bölümünde.</para>

      <para><emphasis>Sembolik bağlar</emphasis><indexterm>
          <primary>bağlantı</primary>

          <secondary>sembolik</secondary>
        </indexterm>, diğer adı ile <emphasis>symlink'ler</emphasis><indexterm>
          <primary>symlink</primary>
        </indexterm>, anlaması en kolay bağ çeşididir. Gerçek bir dosya değil, 
      sistemdeki başka bir dosyaya işaret eden dosyalardır. İçeriklerinde 
      işaret ettikleri dosyanın ismini bulunduran basit bir dosya oldukları 
      için, gerçekte (artık) var olmayan dosyalara da işaret ediyor 
      olabilirler. Örnek olarak <filename>/home/swift/opentasks.txt</filename> 
      dosyasını işaret eden bir sembolik bağ oluşturabilirsiniz, bu dosya 
      (artık) olmasa dahi.</para>

      <para><emphasis>Sert bağlar</emphasis><indexterm>
          <primary>bağlantı</primary>

          <secondary>sert</secondary>
        </indexterm>, NEEDTRANSLATION on the contrary, are immediate links. They actually
      refer to the same location on the disk as their target file (through
      inode's) and the file system will not release this location as free
      space until there are no references to this location. In fact, every
      file you see in the file system is a link to a location. With hard
      links, you just create additional links.</para>

      <para>Due to their technology, hard links can only point to file
      locations on the same medium and they cannot handle directories.</para>

      <para>To create links, use <command>ln</command><indexterm>
          <primary>ln</primary>
        </indexterm> (hard links) or <command>ln -s</command>
      (symlinks):</para>

      <programlisting>$ <command>ln targetfilename newfilename</command>
$ <command>ln -s targetfilename newfilename</command></programlisting>

      <para>Thanks to links, you can manage your files more easily. For
      instance, you can have an important text file located inside
      <filename>~/Documents/Work/Thesis/myThesis.txt</filename> but link to it
      from your home directory (<filename>~/myThesis.txt</filename> points to
      <filename>~/Documents/Work/Thesis/MyThesis.txt</filename>) so that you
      don't have to traverse all these directories every time you want to
      open/edit the file.</para>
    </section>

    <section>
      <title>File / Command Completion</title>

      <para>A powerful feature of most Linux shells is file and command
      completion.</para>

      <para>When you want to edit a file called, for instance, opentasks.txt,
      you can start with typing "<command>nano o</command>" followed by the
      &lt;tab&gt; key. If <filename>opentasks.txt</filename> is the only file
      or directory that starts with an o, the shell will automatically expand
      the command to "<filename>nano opentasks.txt</filename>". If there are
      more files or directories that start with o, typing &lt;tab&gt; twice
      will show you a list of candidates.</para>

      <para>The same is true for commands. If nano is the only command
      starting with na (it isn't, but suppose it is) then typing "na" followed
      by a &lt;tab&gt; expands the command to nano. Pressing &lt;tab&gt; twice
      if it isn't the only command displays all matches:</para>

      <programlisting>$ <command>na</command><emphasis>&lt;tab&gt;&lt;tab&gt;</emphasis>
namei           nautilus
nano            nasl
nasm            native2ascii
$ <command>na</command></programlisting>
    </section>

    <section>
      <title>Switching Terminals</title>

      <para>One of Unix / Linux' advantages is the support for multiple
      terminals<indexterm>
          <primary>virtual terminal</primary>
        </indexterm>. When you are logged on to your system, you are actually
      watching one of the (virtual) terminals, most likely the first one. You
      can switch from one terminal to another using Alt+F# where F# is F1, F2,
      ... If you are on a graphical session, you'll need to use Ctrl+Alt+F#
      first. The graphical screen is positioned at the first terminal that can
      not be used to log on to (most likely Alt+F7).</para>

      <para>The support for multiple terminals allows you to log on to your
      system several times and spread the tasks you want to execute in
      parallel across the various terminals. For instance, if you are
      configuring a program, you might want to have the configuration file
      itself open in one terminal and the program in another.</para>

      <para>Hint: if you are working on the command line, you can also use the
      <command>chvt</command><indexterm>
          <primary>chvt</primary>
        </indexterm> command to switch between terminals: <command>chvt
      2</command> switches to the second terminal (similar to Alt+F2).</para>
    </section>

    <section>
      <title>Logging Out</title>

      <para>To log out from an existing session, enter <command>exit</command>
      or press Ctrl+d:</para>

      <programlisting>captain@seaheaven ~ $ <command>exit</command>

This is seaheaven.homeworld (Linux i686 2.6.23) 22:30:00

seaheaven login: </programlisting>
    </section>

    <section>
      <title>Shutting Down</title>

      <para>Finally, if you want to shut down<indexterm>
          <primary>shutdown</primary>
        </indexterm> your system, you will first need to become root. You can
      do this by switching to another terminal and log on as root, but you can
      also use the su command. This command will ask you to enter the root
      password after which you are known to the system as the root
      user:</para>

      <programlisting>captain@seaheaven ~ $ <command>su -</command>
Password: <emphasis>(Enter root password)</emphasis>
root@seaheaven ~ # </programlisting>

      <para>Now, you can issue the shutdown command to shut down (-h) or reboot<indexterm>
          <primary>reboot</primary>
        </indexterm> (-r) the system immediately:</para>

      <programlisting>root@seaheaven ~ # <command>shutdown -h now</command></programlisting>
    </section>
  </section>

  <section>
    <title>Getting Help</title>

    <para>Linux might seem a bit complex at first, especially because the
    tools novice users use are the same tools that experts use, making the
    tools accept expert options starters wouldn't understand. Handbooks such
    as this one can only help users find their way, but once in a while any
    user, beginner or advanced, will need something to fall back to. Luckily,
    there are several resources you can address...</para>

    <section>
      <title>Man Pages</title>

      <para>The <emphasis>manual page</emphasis><indexterm>
          <primary>manual page</primary>
        </indexterm> is available on the Linux system itself and can be
      accessed through the <command>man</command><indexterm>
          <primary>man</primary>
        </indexterm> command. By entering <command>man</command> followed by
      the command you want information about you receive the manual page of
      that command, explaining what the command does, what syntax you should
      use, what options it supports and what commands or files are related to
      this command.</para>

      <para>The manual page is usually structured as follows:</para>

      <itemizedlist>
        <listitem>
          <para>name of the command with a one-line description</para>
        </listitem>

        <listitem>
          <para>synopsis of the command, showing the syntax the command
          accepts</para>
        </listitem>

        <listitem>
          <para>options of the command with an explanation of each
          option</para>
        </listitem>

        <listitem>
          <para>further information on the command, like usage restrictions,
          default behaviour, ...</para>
        </listitem>

        <listitem>
          <para>copyright and authorship information</para>
        </listitem>

        <listitem>
          <para>related manual pages</para>
        </listitem>
      </itemizedlist>

      <para>Manual pages not only exist for commands, but for files
      (configuration files or device files), system calls and library
      functions (programming related information) and even standards and
      conventions. These topics are categorized in the following sections with
      the accompanying numbers:</para>

      <orderedlist>
        <listitem>
          <para>user commands</para>
        </listitem>

        <listitem>
          <para>system calls</para>
        </listitem>

        <listitem>
          <para>library functions</para>
        </listitem>

        <listitem>
          <para>special files (device files)</para>
        </listitem>

        <listitem>
          <para>file formats and protocols</para>
        </listitem>

        <listitem>
          <para>games and funny programs</para>
        </listitem>

        <listitem>
          <para>overview, conventions and miscellaneous topics</para>
        </listitem>

        <listitem>
          <para>administrative and privileged commands</para>
        </listitem>
      </orderedlist>

      <para>For information about these sections, open up the introduction
      page for each section. For instance, the introduction page for the games
      section can be accessed through <command>man 6 intro</command>. Knowing
      what sections are available can be important, especially when there are
      topics in different sections which have the same name. An example is
      passwd: there is a manual page for the <command>passwd</command> command
      (<command>man 1 passwd</command>) and one for the
      <filename>passwd</filename> file (<command>man 5 passwd</command>). If
      one would enter <command>man passwd</command>, the first section that
      has a manual page for the topic is displayed (in this case, the first
      section).</para>

      <para>Once you are inside a manual page, you can navigate through it
      using the up/down arrow keys and the PgUp/PgDn keys. You can also search
      for some terms (press / followed by the term) and more. A full
      explanation of all the commands of the manual viewer (which, on most
      systems, is the <command>less</command><indexterm>
          <primary>less</primary>
        </indexterm> tool) can be obtained by pressing 'h'.</para>

      <para>To quit viewing the manual page, press 'q'.</para>
    </section>

    <section>
      <title>Info Pages</title>

      <para>Another reference tool on your system is the
      <command>info</command><indexterm>
          <primary>info</primary>
        </indexterm> page help system. The <command>info</command> tool allows
      you to browse through info pages using a hierarchical approach
      (next/previous section, go upwards, ...) as well as using hyperlinks
      (select a topic in the info page to go to the section on that
      topic).</para>

      <para>Let's take a look at the GCC info pages:</para>

      <programlisting>~$ <command>info gcc</command>
...
File: gcc.info,  Node: Top,  Next: G++ and GCC,  Up: (DIR)

Introduction
************

This manual documents how to use the GNU compilers, as well as their
features and incompatibilities, and how to report bugs.  It corresponds
to GCC version 4.1.2.  The internals of the GNU compilers, including
how to port them to new targets and some information about how to write
...</programlisting>

      <para>At the top of the info page you find where you are in the sequence
      of documents (as this is the first page, there is no real previous
      section nor upwards section). The next topic (which you can go to by
      pressing <command>n</command>) is "G++ and GCC".</para>

      <para>Inside the text you will find text snippets following by two
      colons:</para>

      <programlisting>* G++ and GCC::     You can compile C or C++ programs.
* Standards::       Language standards supported by GCC.
* Invoking GCC::    Command options supported by `gcc'.
* C Implementation:: How GCC implements the ISO C specification.
* C Extensions::    GNU extensions to the C language family.
* C++ Extensions::  GNU extensions to the C++ language.
* Objective-C::     GNU Objective-C runtime features.</programlisting>

      <para>These texts are links which allow you to jump to that topic. Go
      with the cursor to "Invoking GCC" and press return:</para>

      <programlisting>File: gcc.info,  Node: Invoking GCC,  Next: C Implementation,  Prev: Standards,    Up: Top

3 GCC Command Options
*********************

When you invoke GCC, it normally does preprocessing, compilation,
assembly and linking.  The "overall options" allow you to stop this
process at an intermediate stage.  For example, the `-c' option says
not to run the linker.  Then the output consists of object files output
by the assembler.</programlisting>

      <para>You are now in the node called "Invoking GCC". The next
      (<command>n</command>) section is "C Implementation", the previous
      (<command>p</command>) is "Standards" and if you go up
      (<command>u</command>), you get to the top of the info document
      again.</para>

      <para>Info pages are well used by various GNU projects (such as GCC).
      However, manual pages are more popular - perhaps because most developers
      find them easier to write.</para>
    </section>

    <section>
      <title>Immediate Syntax Help</title>

      <para>If you are not looking for an explanation on the command but want
      to know its syntax, most commands provide immediate help through the
      <command>-h</command> or <command>--help</command> arguments:</para>

      <programlisting>$ <command>man -h</command>
man, version 1.6e

usage: man [-adfhktwW] [section] [-M path] [-P pager] [-S list]
           [-m system] [-p string] name ...

  a : find all matching entries
  c : do not use cat file
  d : print gobs of debugging information
  D : as for -d, but also display the pages
  f : same as whatis(1)
  h : print this help message
  k : same as apropos(1)
  K : search for a string in all pages
  t : use troff to format pages for printing
  w : print location of man page(s) that would be displayed
      (if no name given: print directories that would be searched)
  W : as for -w, but display filenames only

  C file   : use `file' as configuration file
  M path   : set search path for manual pages to `path'
  P pager  : use program `pager' to display pages
  S list   : colon separated section list
  m system : search for alternate system's man pages
  p string : string tells which preprocessors to run
               e - [n]eqn(1)   p - pic(1)    t - tbl(1)
               g - grap(1)     r - refer(1)  v - vgrind(1)</programlisting>
    </section>

    <section>
      <title>Package-provided Documentation</title>

      <para>Some packages provide more documentation in the form of guides (in
      HTML, PDF or other formats), README files and more. You will find most
      of this documentation at <filename>/usr/share/doc</filename>. Gentoo
      Linux compresses the documents using <command>bzip2</command> or
      <command>gzip</command> (both well known compression tools in the Unix
      world). To view the documents, you will first need to decompress those
      into a location you have write privileges to.</para>

      <para>For instance, the zip package contains a document explaining what
      algorithm the tool uses to (de)compress data:</para>

      <programlisting>$ <command>cd /usr/share/doc/zip-*</command>
$ <command>ls</command>
algorith.txt.bz2   BUGS.bz2            CHANGES.bz2      MANUAL.bz2
README.bz2         timezone.txt.bz2    txtvsbin.txt.bz2 WHATSNEW.bz2
WHERE.bz2           ziplimit.txt.bz2
$ <command>bunzip2 -c algoritm.txt.bz2 &gt; ~/algorithm.txt</command></programlisting>

      <para>The resulting file, <filename>algorithm.txt</filename>, can be
      found in the home directory (<filename>~</filename><indexterm>
          <primary>~</primary>
        </indexterm> is an abbreviation for the home directory of the current
      user). In this case, the file is a regular text file which can be viewed
      through the <command>less</command> command, which is the same command
      used for manual pages.</para>

      <para>In the above example, a redirection is used: the output of one
      command (<command>bunzip2 -c algorithm.txt.bz2</command>) is not shown
      on the screen, but rather redirected into a file
      (<filename>algorithm.txt</filename>). Redirection is discussed later
      on.</para>
    </section>

    <section>
      <title>Online Documentation</title>

      <para>Most projects have extensive documentation available. You are
      certainly advised to take a look at the projects' web sites or search
      through the internet for available guides and books. Sometimes, the best
      documentation is not written by the project itself but by satisfied
      users.</para>
    </section>
  </section>

  <section>
    <title>Exercises</title>

    <orderedlist>
      <listitem>
        <para>Try to organize your home directory in logical sections. For
        instance, create directories where you put your personal documents,
        pictures, work-related documents and temporary documents.</para>
      </listitem>

      <listitem>
        <para>Unix/Linux systems generally offer four compression methods.
        Whereas Zip is well known on the Microsoft Windows operating system,
        Unix/Linux uses GZip or BZip2 together with tar. How is "tar" used
        with gzip/bzip2? What is the fourth compression method?</para>
      </listitem>

      <listitem>
        <para>As stated, Unix/Linux systems have no undo functionality: when
        you remove a file, it is removed. However, due to the technicalities
        of removing files (in essence only the reference to the file is
        removed, but its content remains on disk until it is overwritten)
        there are tools available that help you recover files. Try finding a
        few examples of such file recovery utilities for Linux.</para>
      </listitem>
    </orderedlist>
  </section>

  <section>
    <title>Further Resources</title>

    <itemizedlist>
      <listitem>
        <para><ulink
        url="http://www.tldp.org/LDP/intro-linux/html/index.html">Introduction
        to Linux, A Hands-On Guide</ulink> by Machtelt Garrels (also available
        as <ulink
        url="http://www.tldp.org/LDP/intro-linux/intro-linux.pdf">PDF</ulink>)</para>
      </listitem>
    </itemizedlist>
  </section>
</chapter>
